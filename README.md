# Mirror Worlds Main Server


## Ports

Currently being developed on GNU/Linux systems: Debian 8.6, and Xubuntu
16.04.  It is expected to work on most GNU/Linux systems.


## Package Dependences


### nodeJS

### yui-compressor (optional, build-time only)


## Installing

It builds and installs using GNU make and bash.  In a bash shell, from
the directory with this README file is, run:


```
./configure --prefix=/INSTALLATION/PREFIX && make && make install
```
where ```/INSTALLATION/PREFIX``` the directory to install all the
installed files.  Running ```make``` the first time will download
files from the Internet via ```npm``` and ```wget```.

See:

```
./configure --help
```
for more configuration options.

## Running the server

The Mirror Worlds server is installed as mw_server in the directory
```PREFIX/bin/```.  Run
```mw_server --help```
for help.


#### Example:

From a bash shell:
```
mw_server --doc_root ${HOME}/public_html --http_port=3333 > access.log 2> error.log &
```



# Developer Notes


## File structure

Making nodeJS applications that use many files requires a planning the for
the file directory structure.  No matter how you lay it out there will
always be give and take.  ref: https://gist.github.com/branneman/8048520

1. We decided to keep the installed executables directory (bin/) free of
   any files that the user does not directly execute.  We use the fact
   that NodeJs resolves symbolic links to full file paths in __dirname to
   lib/ where we keep all the code.

2. We decided to keep the test running of the programs not require that
   the package be installed.  The structure of the source files is close
   to that of the installed files.

3. We decided to have the package installation be automated.


## Profiling

- https://nodejs.org/en/docs/guides/simple-profiling/

## Subscription Semantics

The subscription semantics that we define between client and server tends
parallel that of UNIX file semantics with open, write, read, close, and
unlink (remove or delete).  The server acts like the file system part of
the operating system, not knowing what the content (payload) of the file
is.  The client acts like the user of the file system knowing and using
what's in the files (subscriptions).  As in a file system we can open a
file (subscription) creating it or not, and for reading and/or writing.
Dependency structure in the subscriptions are analogous to directories in
a file system.  Circular dependencies can happen, which are analogous to
symlinks in a file system.  You can't create a file before you create the
directory that the file is in, in the same way you can't create a
subscription before you create another subscription that the other
subscription depends on.

Some restrictive options in subscription semantics are:

  - single source subscriptions, or single writer
  - single sink subscriptions, or single reader

Maybe that's analogous to access control lists, or access bit masks in a
file system.

Active server push:

  - adding or removing subscriptions are pushed to the client as
    advertisements or cancelations, and

  - subscription payload (file content) changes are pushed to the client.

  - write requests may come from the server to the client

Analogs of server pushed properties of subscriptions do not exist in file
systems, and are due to the client's ability to act as a accepting
receiver where the client is taking the passive role.  Put another way,
file systems (servers) are usually just passive and do not push and pull
data to and from the user (client).

Other subscription semantics (not like file system):

  - creating subscriptions without specifying name:  The id of the
    subscription is generated by the server.  The server does not care
    that the name is.  Using this method the client may:

    - use the *descriptor* to call a receiver function that is shared by a
      class of subscriptions via *mw.recvPayload(descriptor or id, ..)*, or
    - use the *descriptor* to load a javaScript file which calls
      *mw.recvPayload(descriptor or id, ..)*

Semantics common to a file system:

  - creating subscriptions with a unique name.  The subscription can
    only be created once, so there is an inherit race condition that
    must be dealt with when all the clients run the same code.  Create
    is a race on file systems too when making a file.

So the subscription semantics is like a file system with the additions:
files that push reads and writes to the user (client), and the ability to
create files without a complete name (a class of file names).

It looks kind of like a networked file system with some additional semantics,
some which are more restrictive making it not like a networked file
system.


## Server Record

- **subscriptions** or *subs* the record for a networked events which are
  kept on the server.  Each subscription has the following properties:
  - **parents** subscriptions that this subscription depends on.
    We can get siblings from the parents children.  TODO: Is this
    a general graph with directed links or just a tree?
  - **children** subscriptions that depend on this subscription
  - **writers** a list of clients that write this record
  - **readers** a list of clients that read this record
  - **name** unique name relative to all siblings
  - **descriptor** this is a string that is used by the client and the
    server just sends it to the client as a part of 'newSubscription' for
    this subscription.  The server does not know what this is used for.
  - **id** a unique per-subscription id gotten from a counter on the
    server.  It's an integer.
  - **shortName** a short description that includes the id in it
  - **description** a longer description that may include HTML
  - **payload** the current state of the subscription that was sent from a
    client.  TODO: payloads may need to be able to be queued, timestamped,
    and/or have other properties.
  - **type** for kind of subscription which contains the following
    booleans values:
    - **UNIQUE_SOURCE** only one writer may exist else it's multi-source.
      If the writer is removed the subscription is destroyed.
    - **UNIQUE_SINK** only one reader may exist else it's multi-sink.
      Example: This could be a command request queue.  If the reader is removed
      the subscription is destroyed.
    - **UNIQUE_NAME** siblings may not have the same name.  If unset name
      is null


## Client Record

The client keeps a record of 


## Client to Server Subscription Commands

All commands that are sent from the client to the server:

- **onopen** sets up websocket *onmessage*

- **initiate** server responds to client with *listSubscriptions*
  with an array of subscriptions that is may *open*

- **open** like open(2) in file system.  What is does depends on
  flags sent with it.

- **write**

- **advertise** clients okay after client get open after creation

- **onclose** websocket closes removes appropriate resources

- **close** unsubscribe from a particular subscription

- **destroy** removes the subscription from the server


## Server to Client Subscription Commands

All commands that are sent from server to clients:

- **initiate** server sends after a client connects, via WebSocket server
  event *connection*.  The client receives a client id, from a server
  counter.  The client responds by requesting files and then sending a
  *initiate* command to the server.

- **advertise** send array of subscriptions

- **open** response to open.  Gets subscription id. Client sends
  advertise.

- **destroy** 

- **read** read pushed to client


## Startup

The order of event going down the table:

| To Server     | To Client                                              |
| ------------- | ------------------------------------------------------ |
| ws connect    |                                                        |
|               | initiate - gets client id, adds models                 |
| initiate      |                                                        |
|               | advertise - array of subscriptions, save local list    |
|               | makes and subscribes
| open          |





## Client API

There is not server API.  Extending the projects functionality does not
require writing server code.

- **mw** A singlton object





- **mw.createSource(shortName, description, descriptor, onCallback)**
  create a subscription and make this client a source (writer) to that
  subscription.  The created subscription will have a single writer which
  is the client calling this.  There may be any number of client
  readers.
      - **descriptor** is a class name that is associated with many
        subscriptions 

- **mw.getSubscription(id, shortName, description, descriptor, onCallback)**
  create a subscription if it does not exist and make this client a source
  (writer) to that subscription

